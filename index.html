<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active vs. Lazy Learner Comparison (VQC vs. QKNN)</title>
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load D3.js for plotting -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* 3. Use the Inter font family */
        body {
            font-family: "Inter", sans-serif;
            background-color: #111827; /* bg-gray-900 */
        }
        /* Custom styles for D3 plot */
        .grid-line {
            stroke: #374151; /* bg-gray-700 */
            stroke-opacity: 0.5;
            shape-rendering: crispEdges;
        }
        .domain {
            stroke: #6b7280; /* bg-gray-500 */
        }
        .tick line {
            stroke: #6b7280; /* bg-gray-500 */
        }
        .tick text {
            fill: #d1d5db; /* text-gray-300 */
            font-size: 12px;
        }
        /* Custom scrollbar for log boxes */
        .log-box::-webkit-scrollbar {
            width: 6px;
        }
        .log-box::-webkit-scrollbar-track {
            background: #1f2937; /* bg-gray-800 */
        }
        .log-box::-webkit-scrollbar-thumb {
            background: #4b5563; /* bg-gray-600 */
            border-radius: 3px;
        }
        /* D3 Tooltip */
        .tooltip {
            position: absolute;
            background-color: #1f2937;
            color: #e5e7eb;
            border: 1px solid #4b5563;
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        /* D3 Cost Graph Line */
        .cost-line {
            fill: none;
            stroke: #60a5fa; /* blue-400 */
            stroke-width: 2px;
        }
    </style>
</head>
<body class="text-gray-200 p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">
                Quantum Classifier Comparison
            </h1>
            <p class="text-lg text-gray-400 mt-2">Simulating "Active" (VQC) vs. "Lazy" (QKNN) Learners</p>
        </header>

        <!-- Global Controls -->
        <div class="bg-gray-800 p-4 rounded-lg shadow-xl mb-6">
            <h2 class="text-xl font-semibold mb-4 text-center">Dataset Controls</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="flex flex-col">
                    <label for="dataset" class="font-medium text-sm mb-1">Dataset Type:</label>
                    <select id="dataset" class="bg-gray-700 text-white rounded-md px-3 py-2 border-gray-600 focus:ring-blue-500 focus:border-blue-500">
                        <option value="moons">Moons (Non-Linear)</option>
                        <option value="circles">Circles (Non-Linear)</option>
                        <option value="blobs">Blobs (Linear)</option>
                    </select>
                </div>
                <div class="flex flex-col">
                    <label for="n_samples" class="font-medium text-sm mb-1">Total Samples: <span id="n_samples_label" class="font-bold">200</span></label>
                    <input type="range" id="n_samples" min="50" max="500" value="200" step="10" class="w-full">
                </div>
                <div class="flex flex-col">
                    <label for="noise" class="font-medium text-sm mb-1">Dataset Noise: <span id="noise_label" class="font-bold">0.10</span></label>
                    <input type="range" id="noise" min="0" max="0.5" value="0.1" step="0.01" class="w-full">
                </div>
                <button id="generateData" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 self-end">
                    Generate New Data
                </button>
            </div>
        </div>

        <!-- Main Content: Plot + Comparison Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Plot Area -->
            <div class="lg:col-span-2 bg-gray-800 p-4 rounded-lg shadow-xl min-h-[500px]">
                <h2 class="text-xl font-semibold mb-2 text-center">Classifier Decision Boundaries</h2>
                <div id="plot-container" class="w-full h-[450px] relative">
                    <svg id="plot" width="100%" height="100%"></svg>
                    <div id="plot-tooltip" class="tooltip"></div>
                </div>
                <div class="flex flex-wrap justify-center gap-4 md:gap-6 mt-2">
                    <span class="flex items-center"><span class="w-3 h-3 rounded-full bg-blue-400 mr-2"></span>Data: Class 0</span>
                    <span class="flex items-center"><span class="w-3 h-3 rounded-full bg-red-400 mr-2"></span>Data: Class 1</span>
                    <span class="flex items-center"><span class="w-3 h-3 rounded-sm bg-blue-400/20 mr-2"></span>Region: Predicted Class 0</span>
                    <span class="flex items-center"><span class="w-3 h-3 rounded-sm bg-red-400/20 mr-2"></span>Region: Predicted Class 1</span>
                </div>
            </div>

            <!-- Comparison Cards -->
            <div class="lg:col-span-1 space-y-6">
                
                <!-- VQC Card -->
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                    <h2 class="text-2xl font-semibold mb-2 text-blue-400">Model 1: VQC (Active Learner)</h2>
                    <p class="text-sm text-gray-400 mb-4">
                        Simulates a <strong>Variational Quantum Classifier (VQC)</strong> or Quantum Neural Network. It's an "active" learner that finds optimal parameters through a hybrid training loop. This is <strong>slow to train</strong> but <strong>fast to predict</strong>.
                    </p>
                    <div class="text-xs text-gray-500 bg-gray-900 p-2 rounded-md mb-4">
                        <strong>Simulation:</strong> We use a classical <strong>2-Layer Neural Network (MLP)</strong>. Like a VQC, it's a non-linear model that learns weights iteratively via backpropagation.
                    </div>
                    
                    <!-- VQC Controls -->
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="flex flex-col">
                            <label for="vqc_epochs" class="font-medium text-sm mb-1">Epochs: <span id="vqc_epochs_label" class="font-bold">100</span></label>
                            <input type="range" id="vqc_epochs" min="10" max="300" value="100" step="10" class="w-full">
                        </div>
                        <div class="flex flex-col">
                            <label for="vqc_lr" class="font-medium text-sm mb-1">Learning Rate: <span id="vqc_lr_label" class="font-bold">0.1</span></label>
                            <input type="range" id="vqc_lr" min="0.001" max="1" value="0.1" step="0.001" class="w-full">
                        </div>
                    </div>

                    <button id="runVQC" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200">
                        Train & Run VQC
                    </button>
                    
                    <!-- VQC Metrics -->
                    <h3 class="font-semibold text-gray-300 text-center mb-2">Test Set Performance</h3>
                    <div class="grid grid-cols-3 gap-2 text-center mb-4">
                        <div>
                            <div class="text-xs text-gray-400">Accuracy</div>
                            <div id="vqc_accuracy" class="text-lg font-bold">-</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Train Time</div>
                            <div id="vqc_train_time" class="text-lg font-bold">-</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Predict Time</div>
                            <div id="vqc_predict_time" class="text-lg font-bold">-</div>
                        </div>
                    </div>

                    <!-- VQC Confusion Matrix -->
                    <div class="grid grid-cols-2 gap-1 text-center text-sm mb-4">
                        <div class="bg-gray-700 p-2 rounded-tl-md">
                            <span class="text-xs text-gray-400">True Neg (Pred 0, Actual 0)</span>
                            <div id="vqc_tn" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-tr-md">
                            <span class="text-xs text-gray-400">False Pos (Pred 1, Actual 0)</span>
                            <div id="vqc_fp" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-bl-md">
                            <span class="text-xs text-gray-400">False Neg (Pred 0, Actual 1)</span>
                            <div id="vqc_fn" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-br-md">
                            <span class="text-xs text-gray-400">True Pos (Pred 1, Actual 1)</span>
                            <div id="vqc_tp" class="font-bold text-lg">-</div>
                        </div>
                    </div>
                    
                    <!-- VQC Training Graph -->
                    <h3 class="font-semibold text-gray-300 text-center mb-2">Live Training Cost</h3>
                    <div id="vqc-cost-container" class="w-full h-24 bg-gray-900 rounded-md">
                        <svg id="vqc-cost-plot" width="100%" height="100%"></svg>
                    </div>
                </div>

                <!-- QKNN Card -->
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                    <h2 class="text-2xl font-semibold mb-2 text-red-400">Model 2: QKNN (Lazy Learner)</h2>
                    <p class="text-sm text-gray-400 mb-4">
                        Simulates a <strong>Quantum K-Nearest Neighbors</strong> classifier. It's a "lazy" learner that does <strong>no training</strong>. To classify a new point, it must compute the distance to <em>every</em> training point. This makes "training" <strong>instant</strong> but prediction <strong>very slow</strong>.
                    </p>
                    <div class="text-xs text-gray-500 bg-gray-900 p-2 rounded-md mb-4">
                        <strong>Simulation:</strong> We use a classical <strong>K-Nearest Neighbors (KNN)</strong> algorithm. This perfectly demonstrates the "lazy" trade-off: 0ms train time, but prediction time scales with dataset size.
                    </div>

                    <!-- QKNN Controls -->
                    <div class="grid grid-cols-1 gap-4 mb-4">
                        <div class="flex flex-col">
                            <label for="qknn_k" class="font-medium text-sm mb-1">Neighbors (K): <span id="qknn_k_label" class="font-bold">5</span></label>
                            <input type="range" id="qknn_k" min="1" max="15" value="5" step="1" class="w-full">
                        </div>
                    </div>

                    <button id="runQKNN" class="w-full bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200">
                        Run QKNN
                    </button>
                    
                    <!-- QKNN Metrics -->
                    <h3 class="font-semibold text-gray-300 text-center mb-2">Test Set Performance</h3>
                    <div class="grid grid-cols-3 gap-2 text-center mb-4">
                        <div>
                            <div class="text-xs text-gray-400">Accuracy</div>
                            <div id="qknn_accuracy" class="text-lg font-bold">-</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Train Time</div>
                            <div id="qknn_train_time" class="text-lg font-bold">-</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Predict Time</div>
                            <div id="qknn_predict_time" class="text-lg font-bold">-</div>
                        </div>
                    </div>

                    <!-- QKNN Confusion Matrix -->
                    <div class="grid grid-cols-2 gap-1 text-center text-sm mb-4">
                        <div class="bg-gray-700 p-2 rounded-tl-md">
                            <span class="text-xs text-gray-400">True Neg (Pred 0, Actual 0)</span>
                            <div id="qknn_tn" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-tr-md">
                            <span class="text-xs text-gray-400">False Pos (Pred 1, Actual 0)</span>
                            <div id="qknn_fp" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-bl-md">
                            <span class="text-xs text-gray-400">False Neg (Pred 0, Actual 1)</span>
                            <div id="qknn_fn" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-br-md">
                            <span class="text-xs text-gray-400">True Pos (Pred 1, Actual 1)</span>
                            <div id="qknn_tp" class="font-bold text-lg">-</div>
                        </div>
                    </div>
                    
                    <div class="log-box w-full h-32 bg-gray-900 rounded-md p-2 text-xs text-gray-400 font-mono overflow-y-auto" id="qknn_log">
                        Click "Run QKNN" to start...
                    </div>
                </div>

            </div>
        </div>
        
        <!-- Key Takeaway -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl mt-6">
            <h2 class="text-2xl font-semibold mb-2 text-center text-purple-400">Key Takeaway: The "Active" vs. "Lazy" Trade-Off</h2>
            <p class="text-gray-400 text-center max-w-3xl mx-auto">
                This project demonstrates the fundamental difference between two types of algorithms, which is a key concept in both classical and quantum machine learning.
                <br><br>
                The <strong>VQC (Active)</strong> model spends a lot of time up-front in a "training phase" to learn a compact mathematical function. This makes training slow, but prediction (inference) incredibly fast.
                <br><br>
                The <strong>QKNN (Lazy)</strong> model does zero training. It just stores the data. This makes training instant, but prediction is extremely slow because it must compare every new point to the entire training set.
                <br><br>
                <strong>Try it yourself:</strong> Slide the "Total Samples" to 500 and run both. You'll see the VQC's train time increase, but the QKNN's <strong>predict time</strong> will explode. This is the trade-off in action.
            </p>
        </div>

    </div>

    <!-- 4. Main JavaScript Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Globals ---
            let X_train, y_train, X_test, y_test; // Datasets
            let xScale, yScale; // D3 scales for main plot
            const svg = d3.select("#plot"); // D3 SVG element
            const plotContainer = d3.select("#plot-container");
            const tooltip = d3.select("#plot-tooltip");
            const plotMargin = { top: 20, right: 20, bottom: 30, left: 40 };
            let plotWidth, plotHeight; // Dynamic plot dimensions

            // --- DOM Elements ---
            const datasetSelect = document.getElementById('dataset');
            const nSamplesSlider = document.getElementById('n_samples');
            const nSamplesLabel = document.getElementById('n_samples_label');
            const noiseSlider = document.getElementById('noise');
            const noiseLabel = document.getElementById('noise_label');
            const generateDataBtn = document.getElementById('generateData');
            
            // VQC Elements
            const runVqcBtn = document.getElementById('runVQC');
            const vqcEpochsSlider = document.getElementById('vqc_epochs');
            const vqcEpochsLabel = document.getElementById('vqc_epochs_label');
            const vqcLrSlider = document.getElementById('vqc_lr');
            const vqcLrLabel = document.getElementById('vqc_lr_label');
            const vqcAccuracyEl = document.getElementById('vqc_accuracy');
            const vqcTrainTimeEl = document.getElementById('vqc_train_time');
            const vqcPredictTimeEl = document.getElementById('vqc_predict_time');
            const vqcCostSvg = d3.select("#vqc-cost-plot");
            const vqcMetricEls = {
                tn: document.getElementById('vqc_tn'),
                fp: document.getElementById('vqc_fp'),
                fn: document.getElementById('vqc_fn'),
                tp: document.getElementById('vqc_tp')
            };

            // QKNN Elements
            const runQknnBtn = document.getElementById('runQKNN');
            const qknnKSlider = document.getElementById('qknn_k');
            const qknnKLabel = document.getElementById('qknn_k_label');
            const qknnAccuracyEl = document.getElementById('qknn_accuracy');
            const qknnTrainTimeEl = document.getElementById('qknn_train_time');
            const qknnPredictTimeEl = document.getElementById('qknn_predict_time');
            const qknnLogEl = document.getElementById('qknn_log');
            const qknnMetricEls = {
                tn: document.getElementById('qknn_tn'),
                fp: document.getElementById('qknn_fp'),
                fn: document.getElementById('qknn_fn'),
                tp: document.getElementById('qknn_tp')
            };

            // --- Logging Utility ---
            const log = (el, msg) => {
                el.innerHTML = msg.replace(/\n/g, '<br>');
                el.scrollTop = el.scrollHeight;
            };

            // --- Data Generation ---
            const randn_bm = () => {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            };

            const makeMoons = (n, noise) => {
                const X = [], y = [];
                const n_half = Math.floor(n / 2);
                for (let i = 0; i < n_half; i++) {
                    const angle = (i / n_half) * Math.PI;
                    X.push([Math.cos(angle) + noise * randn_bm(), Math.sin(angle) + noise * randn_bm()]);
                    y.push(0);
                }
                for (let i = 0; i < n_half; i++) {
                    const angle = (i / n_half) * Math.PI;
                    X.push([1 - Math.cos(angle) + noise * randn_bm(), 0.5 - Math.sin(angle) + noise * randn_bm()]);
                    y.push(1);
                }
                return { X, y: y.map(v => [v]) }; // Output shape [n, 1] for NN
            };

            const makeCircles = (n, noise) => {
                const X = [], y = [];
                const n_half = Math.floor(n / 2);
                const r_outer = 1.0, r_inner = 0.5;
                for (let i = 0; i < n_half; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    X.push([r_outer * Math.cos(angle) + noise * randn_bm(), r_outer * Math.sin(angle) + noise * randn_bm()]);
                    y.push(0);
                }
                for (let i = 0; i < n_half; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    X.push([r_inner * Math.cos(angle) + noise * randn_bm(), r_inner * Math.sin(angle) + noise * randn_bm()]);
                    y.push(1);
                }
                return { X, y: y.map(v => [v]) }; // Output shape [n, 1]
            };

            const makeBlobs = (n, noise) => {
                const X = [], y = [];
                const n_half = Math.floor(n / 2);
                const center1 = [-0.5, -0.5], center2 = [0.5, 0.5];
                for (let i = 0; i < n_half; i++) {
                    X.push([center1[0] + noise * randn_bm(), center1[1] + noise * randn_bm()]);
                    y.push(0);
                }
                for (let i = 0; i < n_half; i++) {
                    X.push([center2[0] + noise * randn_bm(), center2[1] + noise * randn_bm()]);
                    y.push(1);
                }
                return { X, y: y.map(v => [v]) }; // Output shape [n, 1]
            };

            const shuffleAndSplit = (X, y, testSplit = 0.3) => {
                const data = X.map((d, i) => ({ x: d, y: y[i] }));
                for (let i = data.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [data[i], data[j]] = [data[j], data[i]];
                }
                const splitIdx = Math.floor(data.length * (1 - testSplit));
                const train = data.slice(0, splitIdx);
                const test = data.slice(splitIdx);
                
                X_train = train.map(d => d.x);
                y_train = train.map(d => d.y);
                X_test = test.map(d => d.x);
                y_test = test.map(d => d.y);
            };

            // --- Plotting ---
            const setupPlot = (X, y) => {
                plotWidth = plotContainer.node().getBoundingClientRect().width - plotMargin.left - plotMargin.right;
                plotHeight = plotContainer.node().getBoundingClientRect().height - plotMargin.top - plotMargin.bottom;

                svg.selectAll("*").remove();
                const g = svg.append("g").attr("transform", `translate(${plotMargin.left}, ${plotMargin.top})`);
                
                const allX = X.map(d => d[0]), allY = X.map(d => d[1]);
                const xDomain = d3.extent(allX), yDomain = d3.extent(allY);
                const xRange = xDomain[1] - xDomain[0], yRange = yDomain[1] - yDomain[0];
                const padding = 0.1;

                xScale = d3.scaleLinear()
                    .domain([xDomain[0] - xRange * padding, xDomain[1] + xRange * padding])
                    .range([0, plotWidth]);
                    
                yScale = d3.scaleLinear()
                    .domain([yDomain[0] - yRange * padding, yDomain[1] + yRange * padding])
                    .range([plotHeight, 0]);

                g.append("g").attr("class", "grid-line").attr("transform", `translate(0, ${plotHeight})`).call(d3.axisBottom(xScale).ticks(10).tickSize(-plotHeight).tickFormat(""));
                g.append("g").attr("class", "grid-line").call(d3.axisLeft(yScale).ticks(10).tickSize(-plotWidth).tickFormat(""));
                g.append("g").attr("class", "axis").attr("transform", `translate(0, ${plotHeight})`).call(d3.axisBottom(xScale).ticks(5));
                g.append("g").attr("class", "axis").call(d3.axisLeft(yScale).ticks(5));
                g.append("g").attr("id", "decision-boundary");
                g.append("g").attr("id", "data-points");
            };

            const plotData = (X, y) => {
                const color = d3.scaleOrdinal().domain([0, 1]).range(["#60a5fa", "#f87171"]); // blue-400, red-400
                const g = svg.select("#data-points");
                g.selectAll("*").remove();

                const data = X.map((d, i) => ({ x: d, y: y[i][0] })); // Flatten y for color

                g.selectAll("circle")
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("cx", d => xScale(d.x[0]))
                    .attr("cy", d => yScale(d.x[1]))
                    .attr("r", 4)
                    .attr("fill", d => color(d.y))
                    .attr("opacity", 0.8)
                    .on("mouseover", (event, d) => {
                        tooltip.style("opacity", 1)
                               .html(`Coords: (${d.x[0].toFixed(2)}, ${d.x[1].toFixed(2)})<br>Class: ${d.y}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.style("opacity", 0);
                    });
            };

            const plotBoundary = (predictFn, color) => {
                const resolution = 40;
                const xPoints = d3.range(xScale.domain()[0], xScale.domain()[1], (xScale.domain()[1] - xScale.domain()[0]) / resolution);
                const yPoints = d3.range(yScale.domain()[0], yScale.domain()[1], (yScale.domain()[1] - yScale.domain()[0]) / resolution);

                const grid = [];
                for (const y of yPoints) {
                    for (const x of xPoints) {
                        grid.push({ x, y, pred: predictFn([x, y]) });
                    }
                }

                const boundary = svg.select("#decision-boundary");
                boundary.selectAll("rect").remove();
                
                boundary.selectAll("rect")
                    .data(grid)
                    .enter()
                    .append("rect")
                    .attr("x", d => xScale(d.x))
                    .attr("y", d => yScale(d.y))
                    .attr("width", plotWidth / resolution + 1)
                    .attr("height", plotHeight / resolution + 1)
                    .attr("fill", d => d.pred === 0 ? color[0] : color[1])
                    .attr("opacity", 0.15)
                    .lower();
            };

            // --- Metrics ---
            const calculateMetrics = (y_true_flat, y_pred) => {
                let correct = 0, tp = 0, fp = 0, tn = 0, fn = 0;
                for (let i = 0; i < y_true_flat.length; i++) {
                    const y_t = y_true_flat[i];
                    const y_p = y_pred[i];
                    if (y_t === y_p) correct++;
                    if (y_t == 1 && y_p == 1) tp++;
                    else if (y_t == 0 && y_p == 1) fp++;
                    else if (y_t == 0 && y_p == 0) tn++;
                    else if (y_t == 1 && y_p == 0) fn++;
                }
                return {
                    accuracy: (correct / y_true_flat.length * 100).toFixed(1),
                    tp, fp, tn, fn
                };
            };
            
            const displayMetrics = (elPrefix, timeMetrics, classMetrics) => {
                document.getElementById(`${elPrefix}_accuracy`).textContent = `${classMetrics.accuracy}%`;
                document.getElementById(`${elPrefix}_train_time`).textContent = `${timeMetrics.train.toFixed(0)} ms`;
                document.getElementById(`${elPrefix}_predict_time`).textContent = `${timeMetrics.predict.toFixed(0)} ms`;
                document.getElementById(`${elPrefix}_tn`).textContent = classMetrics.tn;
                document.getElementById(`${elPrefix}_fp`).textContent = classMetrics.fp;
                document.getElementById(`${elPrefix}_fn`).textContent = classMetrics.fn;
                document.getElementById(`${elPrefix}_tp`).textContent = classMetrics.tp;
            };
            
            const resetMetrics = (elPrefix) => {
                document.getElementById(`${elPrefix}_accuracy`).textContent = `-`;
                document.getElementById(`${elPrefix}_train_time`).textContent = `-`;
                document.getElementById(`${elPrefix}_predict_time`).textContent = `-`;
                document.getElementById(`${elPrefix}_tn`).textContent = `-`;
                document.getElementById(`${elPrefix}_fp`).textContent = `-`;
                document.getElementById(`${elPrefix}_fn`).textContent = `-`;
                document.getElementById(`${elPrefix}_tp`).textContent = `-`;
            };

            // --- Classifier 1: (Mock) VQC -> Neural Network (MLP) ---
            
            // Sigmoid activation function and its derivative
            const sigmoid = (x) => 1 / (1 + Math.exp(-x));
            const sigmoid_derivative = (x) => x * (1 - x);
            // Mean Squared Error cost function
            const mse_loss = (y_true, y_pred) => y_true - y_pred;

            class MLP {
                constructor(input_dim, hidden_dim, output_dim) {
                    // Initialize weights and biases randomly
                    this.W1 = Array.from({ length: input_dim }, () => Array.from({ length: hidden_dim }, () => Math.random() * 2 - 1));
                    this.b1 = Array(hidden_dim).fill(0);
                    this.W2 = Array.from({ length: hidden_dim }, () => Array.from({ length: output_dim }, () => Math.random() * 2 - 1));
                    this.b2 = Array(output_dim).fill(0);
                }

                forward(x) {
                    // x is [1, input_dim]
                    // Z1 = x * W1 + b1
                    const Z1 = Array(this.b1.length).fill(0);
                    for (let j = 0; j < this.W1[0].length; j++) {
                        for (let i = 0; i < this.W1.length; i++) {
                            Z1[j] += x[i] * this.W1[i][j];
                        }
                        Z1[j] += this.b1[j];
                    }
                    const A1 = Z1.map(sigmoid); // Hidden layer output

                    // Z2 = A1 * W2 + b2
                    const Z2 = Array(this.b2.length).fill(0);
                    for (let j = 0; j < this.W2[0].length; j++) {
                        for (let i = 0; i < this.W2.length; i++) {
                            Z2[j] += A1[i] * this.W2[i][j];
                        }
                        Z2[j] += this.b2[j];
                    }
                    const A2 = Z2.map(sigmoid); // Final output
                    return { A1, A2 };
                }

                backward(x, y, A1, A2, lr) {
                    // A2 is [1, output_dim], y is [1, output_dim]
                    // Calculate output layer error
                    const E2 = A2.map((a, i) => (y[i] - a) * sigmoid_derivative(a)); // dCost/dZ2

                    // Calculate hidden layer error
                    const E1 = Array(A1.length).fill(0); // dCost/dZ1
                    for (let i = 0; i < A1.length; i++) {
                        for (let j = 0; j < E2.length; j++) {
                            E1[i] += E2[j] * this.W2[i][j];
                        }
                        E1[i] = E1[i] * sigmoid_derivative(A1[i]);
                    }

                    // Update W2 and b2
                    for (let i = 0; i < this.W2.length; i++) {
                        for (let j = 0; j < this.W2[0].length; j++) {
                            this.W2[i][j] += lr * A1[i] * E2[j];
                        }
                    }
                    for (let j = 0; j < this.b2.length; j++) {
                        this.b2[j] += lr * E2[j];
                    }

                    // Update W1 and b1
                    for (let i = 0; i < this.W1.length; i++) {
                        for (let j = 0; j < this.W1[0].length; j++) {
                            this.W1[i][j] += lr * x[i] * E1[j];
                        }
                    }
                    for (let j = 0; j < this.b1.length; j++) {
                        this.b1[j] += lr * E1[j];
                    }
                }
                
                train(X, y, epochs, lr) {
                    const costHistory = [];
                    for (let epoch = 0; epoch < epochs; epoch++) {
                        let epochCost = 0;
                        for (let i = 0; i < X.length; i++) {
                            const { A1, A2 } = this.forward(X[i]);
                            this.backward(X[i], y[i], A1, A2, lr);
                            epochCost += (y[i][0] - A2[0]) ** 2;
                        }
                        costHistory.push(epochCost / X.length);
                    }
                    return costHistory;
                }

                predict(x) {
                    const { A2 } = this.forward(x);
                    return A2[0] > 0.5 ? 1 : 0;
                }
            }

            let vqcModel = new MLP(2, 4, 1); // 2 inputs, 4 hidden neurons, 1 output
            
            const plotCost = (costHistory) => {
                vqcCostSvg.selectAll("*").remove();
                const costContainer = document.getElementById('vqc-cost-container');
                const width = costContainer.clientWidth;
                const height = costContainer.clientHeight;
                const margin = { top: 10, right: 10, bottom: 20, left: 30 };
                
                const x = d3.scaleLinear()
                    .domain([0, costHistory.length])
                    .range([margin.left, width - margin.right]);
                
                const y = d3.scaleLinear()
                    .domain(d3.extent(costHistory))
                    .range([height - margin.bottom, margin.top]);

                const line = d3.line()
                    .x((d, i) => x(i))
                    .y(d => y(d));

                const g = vqcCostSvg.append("g");

                g.append("path")
                    .datum(costHistory)
                    .attr("class", "cost-line")
                    .attr("d", line);
                    
                // X axis
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0, ${height - margin.bottom})`)
                    .call(d3.axisBottom(x).ticks(5));
                // Y axis
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(${margin.left}, 0)`)
                    .call(d3.axisLeft(y).ticks(3).tickFormat(d3.format(".2f")));
            };

            // --- Classifier 2: (Mock) QKNN ---
            const euclideanDistance = (a, b) => Math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2);
            
            const qknnPredict = (x_new, k) => {
                const distances = X_train.map((x_train, i) => ({
                    dist: euclideanDistance(x_new, x_train),
                    label: y_train[i][0] // y_train is [n, 1], get the value
                }));
                distances.sort((a, b) => a.dist - b.dist);
                const neighbors = distances.slice(0, k);
                const votes = { 0: 0, 1: 0 };
                for (const n of neighbors) votes[n.label]++;
                return votes[0] > votes[1] ? 0 : 1;
            };
            
            // --- Main App Logic ---
            const handleGenerateData = () => {
                const n = parseInt(nSamplesSlider.value);
                const noise = parseFloat(noiseSlider.value);
                let data;
                switch (datasetSelect.value) {
                    case 'moons': data = makeMoons(n, noise); break;
                    case 'circles': data = makeCircles(n, noise); break;
                    case 'blobs': data = makeBlobs(n, noise); break;
                }
                
                shuffleAndSplit(data.X, data.y);
                setupPlot(X_train, y_train);
                plotData(X_train, y_train);
                
                resetMetrics('vqc');
                resetMetrics('qknn');
                vqcCostSvg.selectAll("*").remove();
                log(qknnLogEl, 'Generate new data, then click "Run QKNN".');
            };
            
            const handleRunVQC = () => {
                // 0. Get params
                const epochs = parseInt(vqcEpochsSlider.value);
                const lr = parseFloat(vqcLrSlider.value);

                // 1. Train
                runVqcBtn.disabled = true;
                runVqcBtn.textContent = "Training...";
                
                // Use setTimeout to allow UI to update before blocking
                setTimeout(() => {
                    let startTime = performance.now();
                    vqcModel = new MLP(2, 4, 1); // Re-initialize model
                    const costHistory = vqcModel.train(X_train, y_train, epochs, lr);
                    let trainTime = performance.now() - startTime;
                    
                    // 2. Predict
                    startTime = performance.now();
                    let correct = 0;
                    const predictions = X_test.map(x => vqcModel.predict(x));
                    let predictTime = performance.now() - startTime;
                    
                    // 3. Calculate & Display Metrics
                    const y_test_flat = y_test.map(y => y[0]);
                    const metrics = calculateMetrics(y_test_flat, predictions);
                    displayMetrics('vqc', { train: trainTime, predict: predictTime }, metrics);
                    
                    // 4. Plot
                    plotBoundary(vqcModel.predict.bind(vqcModel), ["#60a5fa", "#f87171"]);
                    plotCost(costHistory);
                    
                    runVqcBtn.disabled = false;
                    runVqcBtn.textContent = "Train & Run VQC";
                }, 10); // 10ms delay
            };

            const handleRunQKNN = () => {
                // 0. Get params
                const k = parseInt(qknnKSlider.value);

                // 1. Train (no-op)
                runQknnBtn.disabled = true;
                runQknnBtn.textContent = "Predicting...";
                let trainTime = 0;
                log(qknnLogEl, "QKNN is 'lazy'. No training needed.\nStarting prediction (this is the slow part)...");
                
                // Use setTimeout to allow UI to update
                setTimeout(() => {
                    // 2. Predict (slow part)
                    let startTime = performance.now();
                    let logMsg = "Running QKNN predictions...\n";
                    log(qknnLogEl, logMsg);
                    
                    const predictions = X_test.map((x, i) => {
                        if (i % 20 === 0 && i > 0) {
                            logMsg += `Predicted ${i}/${X_test.length} points...\n`;
                            log(qknnLogEl, logMsg);
                        }
                        return qknnPredict(x, k);
                    });
                    
                    let predictTime = performance.now() - startTime;
                    logMsg += `\nPrediction complete for ${X_test.length} points.`;
                    log(qknnLogEl, logMsg);

                    // 3. Calculate & Display Metrics
                    const y_test_flat = y_test.map(y => y[0]);
                    const metrics = calculateMetrics(y_test_flat, predictions);
                    displayMetrics('qknn', { train: trainTime, predict: predictTime }, metrics);

                    // 4. Plot boundary
                    plotBoundary((x) => qknnPredict(x, k), ["#60a5fa", "#f87171"]);
                    
                    runQknnBtn.disabled = false;
                    runQknnBtn.textContent = "Run QKNN";
                }, 10); // 10ms delay
            };

            // --- Event Listeners ---
            nSamplesSlider.oninput = () => nSamplesLabel.textContent = nSamplesSlider.value;
            noiseSlider.oninput = () => noiseLabel.textContent = parseFloat(noiseSlider.value).toFixed(2);
            vqcEpochsSlider.oninput = () => vqcEpochsLabel.textContent = vqcEpochsSlider.value;
            vqcLrSlider.oninput = () => vqcLrLabel.textContent = parseFloat(vqcLrSlider.value).toFixed(3);
            qknnKSlider.oninput = () => qknnKLabel.textContent = qknnKSlider.value;
            
            generateDataBtn.onclick = handleGenerateData;
            runVqcBtn.onclick = handleRunVQC;
            runQknnBtn.onclick = handleRunQKNN;

            // Initial data load
            handleGenerateData();
            
            // Handle window resize
            window.onresize = () => {
                if (X_train) {
                    setupPlot(X_train, y_train);
                    plotData(X_train, y_train);
                    // Re-plot boundaries if models exist
                    if (vqcAccuracyEl.textContent !== '-') {
                         plotBoundary(vqcModel.predict.bind(vqcModel), ["#60a5fa", "#f87171"]);
                         // Redraw cost graph (it's fast)
                         handleRunVQC(); // This is a simple way to force redraw
                    }
                    if (qknnAccuracyEl.textContent !== '-') {
                        const k = parseInt(qknnKSlider.value);
                        plotBoundary((x) => qknnPredict(x, k), ["#60a5fa", "#f87171"]);
                    }
                }
            };
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active vs. Lazy Learner Comparison (VQC vs. QKNN)</title>
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load D3.js for plotting -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* 3. Use the Inter font family */
        body {
            font-family: "Inter", sans-serif;
            background-color: #111827; /* bg-gray-900 */
        }
        /* Custom styles for D3 plot */
        .grid-line {
            stroke: #374151; /* bg-gray-700 */
            stroke-opacity: 0.5;
            shape-rendering: crispEdges;
        }
        .domain {
            stroke: #6b7280; /* bg-gray-500 */
        }
        .tick line {
            stroke: #6b7280; /* bg-gray-500 */
        }
        .tick text {
            fill: #d1d5db; /* text-gray-300 */
            font-size: 12px;
        }
        /* Custom scrollbar for log boxes */
        .log-box::-webkit-scrollbar {
            width: 6px;
        }
        .log-box::-webkit-scrollbar-track {
            background: #1f2937; /* bg-gray-800 */
        }
        .log-box::-webkit-scrollbar-thumb {
            background: #4b5563; /* bg-gray-600 */
            border-radius: 3px;
        }
        /* D3 Tooltip */
        .tooltip {
            position: absolute;
            background-color: #1f2937;
            color: #e5e7eb;
            border: 1px solid #4b5563;
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        /* D3 Cost Graph Line */
        .cost-line {
            fill: none;
            stroke: #60a5fa; /* blue-400 */
            stroke-width: 2px;
        }
    </style>
</head>
<body class="text-gray-200 p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">
                Quantum Classifier Comparison
            </h1>
            <p class="text-lg text-gray-400 mt-2">Simulating "Active" (VQC) vs. "Lazy" (QKNN) Learners</p>
        </header>

        <!-- Global Controls -->
        <div class="bg-gray-800 p-4 rounded-lg shadow-xl mb-6">
            <h2 class="text-xl font-semibold mb-4 text-center">Dataset Controls</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="flex flex-col">
                    <label for="dataset" class="font-medium text-sm mb-1">Dataset Type:</label>
                    <select id="dataset" class="bg-gray-700 text-white rounded-md px-3 py-2 border-gray-600 focus:ring-blue-500 focus:border-blue-500">
                        <option value="moons">Moons (Non-Linear)</option>
                        <option value="circles">Circles (Non-Linear)</option>
                        <option value="blobs">Blobs (Linear)</option>
                    </select>
                </div>
                <div class="flex flex-col">
                    <label for="n_samples" class="font-medium text-sm mb-1">Total Samples: <span id="n_samples_label" class="font-bold">200</span></label>
                    <input type="range" id="n_samples" min="50" max="500" value="200" step="10" class="w-full">
                </div>
                <div class="flex flex-col">
                    <label for="noise" class="font-medium text-sm mb-1">Dataset Noise: <span id="noise_label" class="font-bold">0.10</span></label>
                    <input type="range" id="noise" min="0" max="0.5" value="0.1" step="0.01" class="w-full">
                </div>
                <button id="generateData" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 self-end">
                    Generate New Data
                </button>
            </div>
        </div>

        <!-- Main Content: Plot + Comparison Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Plot Area -->
            <div class="lg:col-span-2 bg-gray-800 p-4 rounded-lg shadow-xl min-h-[500px]">
                <h2 class="text-xl font-semibold mb-2 text-center">Classifier Decision Boundaries</h2>
                <div id="plot-container" class="w-full h-[450px] relative">
                    <svg id="plot" width="100%" height="100%"></svg>
                    <div id="plot-tooltip" class="tooltip"></div>
                </div>
                <div class="flex flex-wrap justify-center gap-4 md:gap-6 mt-2">
                    <span class="flex items-center"><span class="w-3 h-3 rounded-full bg-blue-400 mr-2"></span>Data: Class 0</span>
                    <span class="flex items-center"><span class="w-3 h-3 rounded-full bg-red-400 mr-2"></span>Data: Class 1</span>
                    <span class="flex items-center"><span class="w-3 h-3 rounded-sm bg-blue-400/20 mr-2"></span>Region: Predicted Class 0</span>
                    <span class="flex items-center"><span class="w-3 h-3 rounded-sm bg-red-400/20 mr-2"></span>Region: Predicted Class 1</span>
                </div>
            </div>

            <!-- Comparison Cards -->
            <div class="lg:col-span-1 space-y-6">
                
                <!-- VQC Card -->
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                    <h2 class="text-2xl font-semibold mb-2 text-blue-400">Model 1: VQC (Active Learner)</h2>
                    <p class="text-sm text-gray-400 mb-4">
                        Simulates a <strong>Variational Quantum Classifier (VQC)</strong> or Quantum Neural Network. It's an "active" learner that finds optimal parameters through a hybrid training loop. This is <strong>slow to train</strong> but <strong>fast to predict</strong>.
                    </p>
                    <div class="text-xs text-gray-500 bg-gray-900 p-2 rounded-md mb-4">
                        <strong>Simulation:</strong> We use a classical <strong>2-Layer Neural Network (MLP)</strong>. Like a VQC, it's a non-linear model that learns weights iteratively via backpropagation.
                    </div>
                    
                    <!-- VQC Controls -->
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="flex flex-col">
                            <label for="vqc_epochs" class="font-medium text-sm mb-1">Epochs: <span id="vqc_epochs_label" class="font-bold">100</span></label>
                            <input type="range" id="vqc_epochs" min="10" max="300" value="100" step="10" class="w-full">
                        </div>
                        <div class="flex flex-col">
                            <label for="vqc_lr" class="font-medium text-sm mb-1">Learning Rate: <span id="vqc_lr_label" class="font-bold">0.1</span></label>
                            <input type="range" id="vqc_lr" min="0.001" max="1" value="0.1" step="0.001" class="w-full">
                        </div>
                    </div>

                    <button id="runVQC" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200">
                        Train & Run VQC
                    </button>
                    
                    <!-- VQC Metrics -->
                    <h3 class="font-semibold text-gray-300 text-center mb-2">Test Set Performance</h3>
                    <div class="grid grid-cols-3 gap-2 text-center mb-4">
                        <div>
                            <div class="text-xs text-gray-400">Accuracy</div>
                            <div id="vqc_accuracy" class="text-lg font-bold">-</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Train Time</div>
                            <div id="vqc_train_time" class="text-lg font-bold">-</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Predict Time</div>
                            <div id="vqc_predict_time" class="text-lg font-bold">-</div>
                        </div>
                    </div>

                    <!-- VQC Confusion Matrix -->
                    <div class="grid grid-cols-2 gap-1 text-center text-sm mb-4">
                        <div class="bg-gray-700 p-2 rounded-tl-md">
                            <span class="text-xs text-gray-400">True Neg (Pred 0, Actual 0)</span>
                            <div id="vqc_tn" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-tr-md">
                            <span class="text-xs text-gray-400">False Pos (Pred 1, Actual 0)</span>
                            <div id="vqc_fp" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-bl-md">
                            <span class="text-xs text-gray-400">False Neg (Pred 0, Actual 1)</span>
                            <div id="vqc_fn" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-br-md">
                            <span class="text-xs text-gray-400">True Pos (Pred 1, Actual 1)</span>
                            <div id="vqc_tp" class="font-bold text-lg">-</div>
                        </div>
                    </div>
                    
                    <!-- VQC Training Graph -->
                    <h3 class="font-semibold text-gray-300 text-center mb-2">Live Training Cost</h3>
                    <div id="vqc-cost-container" class="w-full h-24 bg-gray-900 rounded-md">
                        <svg id="vqc-cost-plot" width="100%" height="100%"></svg>
                    </div>
                </div>

                <!-- QKNN Card -->
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
                    <h2 class="text-2xl font-semibold mb-2 text-red-400">Model 2: QKNN (Lazy Learner)</h2>
                    <p class="text-sm text-gray-400 mb-4">
                        Simulates a <strong>Quantum K-Nearest Neighbors</strong> classifier. It's a "lazy" learner that does <strong>no training</strong>. To classify a new point, it must compute the distance to <em>every</em> training point. This makes "training" <strong>instant</strong> but prediction <strong>very slow</strong>.
                    </p>
                    <div class="text-xs text-gray-500 bg-gray-900 p-2 rounded-md mb-4">
                        <strong>Simulation:</strong> We use a classical <strong>K-Nearest Neighbors (KNN)</strong> algorithm. This perfectly demonstrates the "lazy" trade-off: 0ms train time, but prediction time scales with dataset size.
                    </div>

                    <!-- QKNN Controls -->
                    <div class="grid grid-cols-1 gap-4 mb-4">
                        <div class="flex flex-col">
                            <label for="qknn_k" class="font-medium text-sm mb-1">Neighbors (K): <span id="qknn_k_label" class="font-bold">5</span></label>
                            <input type="range" id="qknn_k" min="1" max="15" value="5" step="1" class="w-full">
                        </div>
                    </div>

                    <button id="runQKNN" class="w-full bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200">
                        Run QKNN
                    </button>
                    
                    <!-- QKNN Metrics -->
                    <h3 class="font-semibold text-gray-300 text-center mb-2">Test Set Performance</h3>
                    <div class="grid grid-cols-3 gap-2 text-center mb-4">
                        <div>
                            <div class="text-xs text-gray-400">Accuracy</div>
                            <div id="qknn_accuracy" class="text-lg font-bold">-</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Train Time</div>
                            <div id="qknn_train_time" class="text-lg font-bold">-</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Predict Time</div>
                            <div id="qknn_predict_time" class="text-lg font-bold">-</div>
                        </div>
                    </div>

                    <!-- QKNN Confusion Matrix -->
                    <div class="grid grid-cols-2 gap-1 text-center text-sm mb-4">
                        <div class="bg-gray-700 p-2 rounded-tl-md">
                            <span class="text-xs text-gray-400">True Neg (Pred 0, Actual 0)</span>
                            <div id="qknn_tn" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-tr-md">
                            <span class="text-xs text-gray-400">False Pos (Pred 1, Actual 0)</span>
                            <div id="qknn_fp" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-bl-md">
                            <span class="text-xs text-gray-400">False Neg (Pred 0, Actual 1)</span>
                            <div id="qknn_fn" class="font-bold text-lg">-</div>
                        </div>
                        <div class="bg-gray-700 p-2 rounded-br-md">
                            <span class="text-xs text-gray-400">True Pos (Pred 1, Actual 1)</span>
                            <div id="qknn_tp" class="font-bold text-lg">-</div>
                        </div>
                    </div>
                    
                    <div class="log-box w-full h-32 bg-gray-900 rounded-md p-2 text-xs text-gray-400 font-mono overflow-y-auto" id="qknn_log">
                        Click "Run QKNN" to start...
                    </div>
                </div>

            </div>
        </div>
        
        <!-- Key Takeaway -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl mt-6">
            <h2 class="text-2xl font-semibold mb-2 text-center text-purple-400">Key Takeaway: The "Active" vs. "Lazy" Trade-Off</h2>
            <p class="text-gray-400 text-center max-w-3xl mx-auto">
                This project demonstrates the fundamental difference between two types of algorithms, which is a key concept in both classical and quantum machine learning.
                <br><br>
                The <strong>VQC (Active)</strong> model spends a lot of time up-front in a "training phase" to learn a compact mathematical function. This makes training slow, but prediction (inference) incredibly fast.
                <br><br>
                The <strong>QKNN (Lazy)</strong> model does zero training. It just stores the data. This makes training instant, but prediction is extremely slow because it must compare every new point to the entire training set.
                <br><br>
                <strong>Try it yourself:</strong> Slide the "Total Samples" to 500 and run both. You'll see the VQC's train time increase, but the QKNN's <strong>predict time</strong> will explode. This is the trade-off in action.
            </p>
        </div>

    </div>

    <!-- 4. Main JavaScript Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Globals ---
            let X_train, y_train, X_test, y_test; // Datasets
            let xScale, yScale; // D3 scales for main plot
            const svg = d3.select("#plot"); // D3 SVG element
            const plotContainer = d3.select("#plot-container");
            const tooltip = d3.select("#plot-tooltip");
            const plotMargin = { top: 20, right: 20, bottom: 30, left: 40 };
            let plotWidth, plotHeight; // Dynamic plot dimensions

            // --- DOM Elements ---
            const datasetSelect = document.getElementById('dataset');
            const nSamplesSlider = document.getElementById('n_samples');
            const nSamplesLabel = document.getElementById('n_samples_label');
            const noiseSlider = document.getElementById('noise');
            const noiseLabel = document.getElementById('noise_label');
            const generateDataBtn = document.getElementById('generateData');
            
            // VQC Elements
            const runVqcBtn = document.getElementById('runVQC');
            const vqcEpochsSlider = document.getElementById('vqc_epochs');
            const vqcEpochsLabel = document.getElementById('vqc_epochs_label');
            const vqcLrSlider = document.getElementById('vqc_lr');
            const vqcLrLabel = document.getElementById('vqc_lr_label');
            const vqcAccuracyEl = document.getElementById('vqc_accuracy');
            const vqcTrainTimeEl = document.getElementById('vqc_train_time');
            const vqcPredictTimeEl = document.getElementById('vqc_predict_time');
            const vqcCostSvg = d3.select("#vqc-cost-plot");
            const vqcMetricEls = {
                tn: document.getElementById('vqc_tn'),
                fp: document.getElementById('vqc_fp'),
                fn: document.getElementById('vqc_fn'),
                tp: document.getElementById('vqc_tp')
            };

            // QKNN Elements
            const runQknnBtn = document.getElementById('runQKNN');
            const qknnKSlider = document.getElementById('qknn_k');
            const qknnKLabel = document.getElementById('qknn_k_label');
            const qknnAccuracyEl = document.getElementById('qknn_accuracy');
            const qknnTrainTimeEl = document.getElementById('qknn_train_time');
            const qknnPredictTimeEl = document.getElementById('qknn_predict_time');
            const qknnLogEl = document.getElementById('qknn_log');
            const qknnMetricEls = {
                tn: document.getElementById('qknn_tn'),
                fp: document.getElementById('qknn_fp'),
                fn: document.getElementById('qknn_fn'),
                tp: document.getElementById('qknn_tp')
            };

            // --- Logging Utility ---
            const log = (el, msg) => {
                el.innerHTML = msg.replace(/\n/g, '<br>');
                el.scrollTop = el.scrollHeight;
            };

            // --- Data Generation ---
            const randn_bm = () => {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            };

            const makeMoons = (n, noise) => {
                const X = [], y = [];
                const n_half = Math.floor(n / 2);
                for (let i = 0; i < n_half; i++) {
                    const angle = (i / n_half) * Math.PI;
                    X.push([Math.cos(angle) + noise * randn_bm(), Math.sin(angle) + noise * randn_bm()]);
                    y.push(0);
                }
                for (let i = 0; i < n_half; i++) {
                    const angle = (i / n_half) * Math.PI;
                    X.push([1 - Math.cos(angle) + noise * randn_bm(), 0.5 - Math.sin(angle) + noise * randn_bm()]);
                    y.push(1);
                }
                return { X, y: y.map(v => [v]) }; // Output shape [n, 1] for NN
            };

            const makeCircles = (n, noise) => {
                const X = [], y = [];
                const n_half = Math.floor(n / 2);
                const r_outer = 1.0, r_inner = 0.5;
                for (let i = 0; i < n_half; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    X.push([r_outer * Math.cos(angle) + noise * randn_bm(), r_outer * Math.sin(angle) + noise * randn_bm()]);
                    y.push(0);
                }
                for (let i = 0; i < n_half; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    X.push([r_inner * Math.cos(angle) + noise * randn_bm(), r_inner * Math.sin(angle) + noise * randn_bm()]);
                    y.push(1);
                }
                return { X, y: y.map(v => [v]) }; // Output shape [n, 1]
            };

            const makeBlobs = (n, noise) => {
                const X = [], y = [];
                const n_half = Math.floor(n / 2);
                const center1 = [-0.5, -0.5], center2 = [0.5, 0.5];
                for (let i = 0; i < n_half; i++) {
                    X.push([center1[0] + noise * randn_bm(), center1[1] + noise * randn_bm()]);
                    y.push(0);
                }
                for (let i = 0; i < n_half; i++) {
                    X.push([center2[0] + noise * randn_bm(), center2[1] + noise * randn_bm()]);
                    y.push(1);
                }
                return { X, y: y.map(v => [v]) }; // Output shape [n, 1]
            };

            const shuffleAndSplit = (X, y, testSplit = 0.3) => {
                const data = X.map((d, i) => ({ x: d, y: y[i] }));
                for (let i = data.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [data[i], data[j]] = [data[j], data[i]];
                }
                const splitIdx = Math.floor(data.length * (1 - testSplit));
                const train = data.slice(0, splitIdx);
                const test = data.slice(splitIdx);
                
                X_train = train.map(d => d.x);
                y_train = train.map(d => d.y);
                X_test = test.map(d => d.x);
                y_test = test.map(d => d.y);
            };

            // --- Plotting ---
            const setupPlot = (X, y) => {
                plotWidth = plotContainer.node().getBoundingClientRect().width - plotMargin.left - plotMargin.right;
                plotHeight = plotContainer.node().getBoundingClientRect().height - plotMargin.top - plotMargin.bottom;

                svg.selectAll("*").remove();
                const g = svg.append("g").attr("transform", `translate(${plotMargin.left}, ${plotMargin.top})`);
                
                const allX = X.map(d => d[0]), allY = X.map(d => d[1]);
                const xDomain = d3.extent(allX), yDomain = d3.extent(allY);
                const xRange = xDomain[1] - xDomain[0], yRange = yDomain[1] - yDomain[0];
                const padding = 0.1;

                xScale = d3.scaleLinear()
                    .domain([xDomain[0] - xRange * padding, xDomain[1] + xRange * padding])
                    .range([0, plotWidth]);
                    
                yScale = d3.scaleLinear()
                    .domain([yDomain[0] - yRange * padding, yDomain[1] + yRange * padding])
                    .range([plotHeight, 0]);

                g.append("g").attr("class", "grid-line").attr("transform", `translate(0, ${plotHeight})`).call(d3.axisBottom(xScale).ticks(10).tickSize(-plotHeight).tickFormat(""));
                g.append("g").attr("class", "grid-line").call(d3.axisLeft(yScale).ticks(10).tickSize(-plotWidth).tickFormat(""));
                g.append("g").attr("class", "axis").attr("transform", `translate(0, ${plotHeight})`).call(d3.axisBottom(xScale).ticks(5));
                g.append("g").attr("class", "axis").call(d3.axisLeft(yScale).ticks(5));
                g.append("g").attr("id", "decision-boundary");
                g.append("g").attr("id", "data-points");
            };

            const plotData = (X, y) => {
                const color = d3.scaleOrdinal().domain([0, 1]).range(["#60a5fa", "#f87171"]); // blue-400, red-400
                const g = svg.select("#data-points");
                g.selectAll("*").remove();

                const data = X.map((d, i) => ({ x: d, y: y[i][0] })); // Flatten y for color

                g.selectAll("circle")
                    .data(data)
                    .enter()
                    .append("circle")
                    .attr("cx", d => xScale(d.x[0]))
                    .attr("cy", d => yScale(d.x[1]))
                    .attr("r", 4)
                    .attr("fill", d => color(d.y))
                    .attr("opacity", 0.8)
                    .on("mouseover", (event, d) => {
                        tooltip.style("opacity", 1)
                               .html(`Coords: (${d.x[0].toFixed(2)}, ${d.x[1].toFixed(2)})<br>Class: ${d.y}`);
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 15) + "px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.style("opacity", 0);
                    });
            };

            const plotBoundary = (predictFn, color) => {
                const resolution = 40;
                const xPoints = d3.range(xScale.domain()[0], xScale.domain()[1], (xScale.domain()[1] - xScale.domain()[0]) / resolution);
                const yPoints = d3.range(yScale.domain()[0], yScale.domain()[1], (yScale.domain()[1] - yScale.domain()[0]) / resolution);

                const grid = [];
                for (const y of yPoints) {
                    for (const x of xPoints) {
                        grid.push({ x, y, pred: predictFn([x, y]) });
                    }
                }

                const boundary = svg.select("#decision-boundary");
                boundary.selectAll("rect").remove();
                
                boundary.selectAll("rect")
                    .data(grid)
                    .enter()
                    .append("rect")
                    .attr("x", d => xScale(d.x))
                    .attr("y", d => yScale(d.y))
                    .attr("width", plotWidth / resolution + 1)
                    .attr("height", plotHeight / resolution + 1)
                    .attr("fill", d => d.pred === 0 ? color[0] : color[1])
                    .attr("opacity", 0.15)
                    .lower();
            };

            // --- Metrics ---
            const calculateMetrics = (y_true_flat, y_pred) => {
                let correct = 0, tp = 0, fp = 0, tn = 0, fn = 0;
                for (let i = 0; i < y_true_flat.length; i++) {
                    const y_t = y_true_flat[i];
                    const y_p = y_pred[i];
                    if (y_t === y_p) correct++;
                    if (y_t == 1 && y_p == 1) tp++;
                    else if (y_t == 0 && y_p == 1) fp++;
                    else if (y_t == 0 && y_p == 0) tn++;
                    else if (y_t == 1 && y_p == 0) fn++;
                }
                return {
                    accuracy: (correct / y_true_flat.length * 100).toFixed(1),
                    tp, fp, tn, fn
                };
            };
            
            const displayMetrics = (elPrefix, timeMetrics, classMetrics) => {
                document.getElementById(`${elPrefix}_accuracy`).textContent = `${classMetrics.accuracy}%`;
                document.getElementById(`${elPrefix}_train_time`).textContent = `${timeMetrics.train.toFixed(0)} ms`;
                document.getElementById(`${elPrefix}_predict_time`).textContent = `${timeMetrics.predict.toFixed(0)} ms`;
                document.getElementById(`${elPrefix}_tn`).textContent = classMetrics.tn;
                document.getElementById(`${elPrefix}_fp`).textContent = classMetrics.fp;
                document.getElementById(`${elPrefix}_fn`).textContent = classMetrics.fn;
                document.getElementById(`${elPrefix}_tp`).textContent = classMetrics.tp;
            };
            
            const resetMetrics = (elPrefix) => {
                document.getElementById(`${elPrefix}_accuracy`).textContent = `-`;
                document.getElementById(`${elPrefix}_train_time`).textContent = `-`;
                document.getElementById(`${elPrefix}_predict_time`).textContent = `-`;
                document.getElementById(`${elPrefix}_tn`).textContent = `-`;
                document.getElementById(`${elPrefix}_fp`).textContent = `-`;
                document.getElementById(`${elPrefix}_fn`).textContent = `-`;
                document.getElementById(`${elPrefix}_tp`).textContent = `-`;
            };

            // --- Classifier 1: (Mock) VQC -> Neural Network (MLP) ---
            
            // Sigmoid activation function and its derivative
            const sigmoid = (x) => 1 / (1 + Math.exp(-x));
            const sigmoid_derivative = (x) => x * (1 - x);
            // Mean Squared Error cost function
            const mse_loss = (y_true, y_pred) => y_true - y_pred;

            class MLP {
                constructor(input_dim, hidden_dim, output_dim) {
                    // Initialize weights and biases randomly
                    this.W1 = Array.from({ length: input_dim }, () => Array.from({ length: hidden_dim }, () => Math.random() * 2 - 1));
                    this.b1 = Array(hidden_dim).fill(0);
                    this.W2 = Array.from({ length: hidden_dim }, () => Array.from({ length: output_dim }, () => Math.random() * 2 - 1));
                    this.b2 = Array(output_dim).fill(0);
                }

                forward(x) {
                    // x is [1, input_dim]
                    // Z1 = x * W1 + b1
                    const Z1 = Array(this.b1.length).fill(0);
                    for (let j = 0; j < this.W1[0].length; j++) {
                        for (let i = 0; i < this.W1.length; i++) {
                            Z1[j] += x[i] * this.W1[i][j];
                        }
                        Z1[j] += this.b1[j];
                    }
                    const A1 = Z1.map(sigmoid); // Hidden layer output

                    // Z2 = A1 * W2 + b2
                    const Z2 = Array(this.b2.length).fill(0);
                    for (let j = 0; j < this.W2[0].length; j++) {
                        for (let i = 0; i < this.W2.length; i++) {
                            Z2[j] += A1[i] * this.W2[i][j];
                        }
                        Z2[j] += this.b2[j];
                    }
                    const A2 = Z2.map(sigmoid); // Final output
                    return { A1, A2 };
                }

                backward(x, y, A1, A2, lr) {
                    // A2 is [1, output_dim], y is [1, output_dim]
                    // Calculate output layer error
                    const E2 = A2.map((a, i) => (y[i] - a) * sigmoid_derivative(a)); // dCost/dZ2

                    // Calculate hidden layer error
                    const E1 = Array(A1.length).fill(0); // dCost/dZ1
                    for (let i = 0; i < A1.length; i++) {
                        for (let j = 0; j < E2.length; j++) {
                            E1[i] += E2[j] * this.W2[i][j];
                        }
                        E1[i] = E1[i] * sigmoid_derivative(A1[i]);
                    }

                    // Update W2 and b2
                    for (let i = 0; i < this.W2.length; i++) {
                        for (let j = 0; j < this.W2[0].length; j++) {
                            this.W2[i][j] += lr * A1[i] * E2[j];
                        }
                    }
                    for (let j = 0; j < this.b2.length; j++) {
                        this.b2[j] += lr * E2[j];
                    }

                    // Update W1 and b1
                    for (let i = 0; i < this.W1.length; i++) {
                        for (let j = 0; j < this.W1[0].length; j++) {
                            this.W1[i][j] += lr * x[i] * E1[j];
                        }
                    }
                    for (let j = 0; j < this.b1.length; j++) {
                        this.b1[j] += lr * E1[j];
                    }
                }
                
                train(X, y, epochs, lr) {
                    const costHistory = [];
                    for (let epoch = 0; epoch < epochs; epoch++) {
                        let epochCost = 0;
                        for (let i = 0; i < X.length; i++) {
                            const { A1, A2 } = this.forward(X[i]);
                            this.backward(X[i], y[i], A1, A2, lr);
                            epochCost += (y[i][0] - A2[0]) ** 2;
                        }
                        costHistory.push(epochCost / X.length);
                    }
                    return costHistory;
                }

                predict(x) {
                    const { A2 } = this.forward(x);
                    return A2[0] > 0.5 ? 1 : 0;
                }
            }

            let vqcModel = new MLP(2, 4, 1); // 2 inputs, 4 hidden neurons, 1 output
            
            const plotCost = (costHistory) => {
                vqcCostSvg.selectAll("*").remove();
                const costContainer = document.getElementById('vqc-cost-container');
                const width = costContainer.clientWidth;
                const height = costContainer.clientHeight;
                const margin = { top: 10, right: 10, bottom: 20, left: 30 };
                
                const x = d3.scaleLinear()
                    .domain([0, costHistory.length])
                    .range([margin.left, width - margin.right]);
                
                const y = d3.scaleLinear()
                    .domain(d3.extent(costHistory))
                    .range([height - margin.bottom, margin.top]);

                const line = d3.line()
                    .x((d, i) => x(i))
                    .y(d => y(d));

                const g = vqcCostSvg.append("g");

                g.append("path")
                    .datum(costHistory)
                    .attr("class", "cost-line")
                    .attr("d", line);
                    
                // X axis
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0, ${height - margin.bottom})`)
                    .call(d3.axisBottom(x).ticks(5));
                // Y axis
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(${margin.left}, 0)`)
                    .call(d3.axisLeft(y).ticks(3).tickFormat(d3.format(".2f")));
            };

            // --- Classifier 2: (Mock) QKNN ---
            const euclideanDistance = (a, b) => Math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2);
            
            const qknnPredict = (x_new, k) => {
                const distances = X_train.map((x_train, i) => ({
                    dist: euclideanDistance(x_new, x_train),
                    label: y_train[i][0] // y_train is [n, 1], get the value
                }));
                distances.sort((a, b) => a.dist - b.dist);
                const neighbors = distances.slice(0, k);
                const votes = { 0: 0, 1: 0 };
                for (const n of neighbors) votes[n.label]++;
                return votes[0] > votes[1] ? 0 : 1;
            };
            
            // --- Main App Logic ---
            const handleGenerateData = () => {
                const n = parseInt(nSamplesSlider.value);
                const noise = parseFloat(noiseSlider.value);
                let data;
                switch (datasetSelect.value) {
                    case 'moons': data = makeMoons(n, noise); break;
                    case 'circles': data = makeCircles(n, noise); break;
                    case 'blobs': data = makeBlobs(n, noise); break;
                }
                
                shuffleAndSplit(data.X, data.y);
                setupPlot(X_train, y_train);
                plotData(X_train, y_train);
                
                resetMetrics('vqc');
                resetMetrics('qknn');
                vqcCostSvg.selectAll("*").remove();
                log(qknnLogEl, 'Generate new data, then click "Run QKNN".');
            };
            
            const handleRunVQC = () => {
                // 0. Get params
                const epochs = parseInt(vqcEpochsSlider.value);
                const lr = parseFloat(vqcLrSlider.value);

                // 1. Train
                runVqcBtn.disabled = true;
                runVqcBtn.textContent = "Training...";
                
                // Use setTimeout to allow UI to update before blocking
                setTimeout(() => {
                    let startTime = performance.now();
                    vqcModel = new MLP(2, 4, 1); // Re-initialize model
                    const costHistory = vqcModel.train(X_train, y_train, epochs, lr);
                    let trainTime = performance.now() - startTime;
                    
                    // 2. Predict
                    startTime = performance.now();
                    let correct = 0;
                    const predictions = X_test.map(x => vqcModel.predict(x));
                    let predictTime = performance.now() - startTime;
                    
                    // 3. Calculate & Display Metrics
                    const y_test_flat = y_test.map(y => y[0]);
                    const metrics = calculateMetrics(y_test_flat, predictions);
                    displayMetrics('vqc', { train: trainTime, predict: predictTime }, metrics);
                    
                    // 4. Plot
                    plotBoundary(vqcModel.predict.bind(vqcModel), ["#60a5fa", "#f87171"]);
                    plotCost(costHistory);
                    
                    runVqcBtn.disabled = false;
                    runVqcBtn.textContent = "Train & Run VQC";
                }, 10); // 10ms delay
            };

            const handleRunQKNN = () => {
                // 0. Get params
                const k = parseInt(qknnKSlider.value);

                // 1. Train (no-op)
                runQknnBtn.disabled = true;
                runQknnBtn.textContent = "Predicting...";
                let trainTime = 0;
                log(qknnLogEl, "QKNN is 'lazy'. No training needed.\nStarting prediction (this is the slow part)...");
                
                // Use setTimeout to allow UI to update
                setTimeout(() => {
                    // 2. Predict (slow part)
                    let startTime = performance.now();
                    let logMsg = "Running QKNN predictions...\n";
                    log(qknnLogEl, logMsg);
                    
                    const predictions = X_test.map((x, i) => {
                        if (i % 20 === 0 && i > 0) {
                            logMsg += `Predicted ${i}/${X_test.length} points...\n`;
                            log(qknnLogEl, logMsg);
                        }
                        return qknnPredict(x, k);
                    });
                    
                    let predictTime = performance.now() - startTime;
                    logMsg += `\nPrediction complete for ${X_test.length} points.`;
                    log(qknnLogEl, logMsg);

                    // 3. Calculate & Display Metrics
                    const y_test_flat = y_test.map(y => y[0]);
                    const metrics = calculateMetrics(y_test_flat, predictions);
                    displayMetrics('qknn', { train: trainTime, predict: predictTime }, metrics);

                    // 4. Plot boundary
                    plotBoundary((x) => qknnPredict(x, k), ["#60a5fa", "#f87171"]);
                    
                    runQknnBtn.disabled = false;
                    runQknnBtn.textContent = "Run QKNN";
                }, 10); // 10ms delay
            };

            // --- Event Listeners ---
            nSamplesSlider.oninput = () => nSamplesLabel.textContent = nSamplesSlider.value;
            noiseSlider.oninput = () => noiseLabel.textContent = parseFloat(noiseSlider.value).toFixed(2);
            vqcEpochsSlider.oninput = () => vqcEpochsLabel.textContent = vqcEpochsSlider.value;
            vqcLrSlider.oninput = () => vqcLrLabel.textContent = parseFloat(vqcLrSlider.value).toFixed(3);
            qknnKSlider.oninput = () => qknnKLabel.textContent = qknnKSlider.value;
            
            generateDataBtn.onclick = handleGenerateData;
            runVqcBtn.onclick = handleRunVQC;
            runQknnBtn.onclick = handleRunQKNN;

            // Initial data load
            handleGenerateData();
            
            // Handle window resize
            window.onresize = () => {
                if (X_train) {
                    setupPlot(X_train, y_train);
                    plotData(X_train, y_train);
                    // Re-plot boundaries if models exist
                    if (vqcAccuracyEl.textContent !== '-') {
                         plotBoundary(vqcModel.predict.bind(vqcModel), ["#60a5fa", "#f87171"]);
                         // Redraw cost graph (it's fast)
                         handleRunVQC(); // This is a simple way to force redraw
                    }
                    if (qknnAccuracyEl.textContent !== '-') {
                        const k = parseInt(qknnKSlider.value);
                        plotBoundary((x) => qknnPredict(x, k), ["#60a5fa", "#f87171"]);
                    }
                }
            };
        });
    </script>
</body>
</html>

